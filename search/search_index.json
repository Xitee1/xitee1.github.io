{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome!","text":""},{"location":"#welcome","title":"Welcome!","text":"<p>Welcome to my new documentation page!</p> <p>This is my new home page where I will publish all my documentations that I've written while trying out some things. Expect many articles about everything computer related soon!</p> <p>Please note that english is not my primary language, so expect some grammar issues here and there. You are welcome to open an issue in the repo about no matter how small mistake you encounter, or even better, open a pull request. This will also help me to improve my english skills </p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2025/12/06/vhs-decode---part-1/","title":"VHS-Decode - Part 1","text":""},{"location":"blog/2025/12/06/vhs-decode---part-1/#vhs-decode-part-1","title":"VHS-Decode - Part 1","text":"<p>This tutorial is exclusively for capturing VHS tapes</p> <p>This tutorial (or rather blog) shows you start to end on how to do your very first video-only capture with vhs-decode in Linux. Capturing audio and improving the quality will come in later parts of this blog (if I manage to understand it :laught:). It's meant for absolute beginners, although it's assumed that you have some basic technical understanding + skills and know how to use the terminal in Linux.</p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#requirements","title":"Requirements","text":""},{"location":"blog/2025/12/06/vhs-decode---part-1/#skills","title":"Skills","text":"<ul> <li>Basic soldering skills</li> <li>Basic Linux &amp; Terminal understanding (includes knowing common commands, e.g. changing directory, moving files, ...)</li> </ul>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#main-parts","title":"Main parts","text":"<ul> <li>PC with two spare PCIe slots and Linux as OS: For beginners preferred Linux Mint or at least Debian based (Linux Mint is based on Ubuntu which is based on Debian), most other distros work too, but in that case you should really know your distro.</li> <li>VCR (Video Cassette Recorder) (your VHS player)</li> <li>Optional: TV/Monitor for the VCR (just for viewing the tape during capture)</li> </ul>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#miscellaneous-parts-for-vhs-decode","title":"Miscellaneous parts for vhs-decode","text":"<ul> <li> <p>Soldering iron and belonging tools</p> </li> <li> <p>CX Card(s) (you'll need two of them to capture video and audio because VHS uses two channels, but in this first test we're only going to capture video, so one is enough for now)</p> </li> <li> <p>BNC Female Jack Bulkhead To SMA Male SMA Plug </p> <p></p> </li> <li> <p>SMA Male to SMA Male (or two separate male cables with no connector at the other end, but I found it's easier to find a male to male cable and just cut it in half)</p> <p></p> </li> <li> <p>RG316 BNC Male to BNC Male </p> <p></p> </li> <li> <p>BNC Female Right Angle 90 Degree Plug (make sure they look like in this image, there are lots of different variants and this is the one that fits to the CX cards) </p> <p></p> </li> <li> <p>10uF Capacitor, preferred ceramic but if you have a spare electrolytic it'll do, but there you need to be aware of the polarization (or just directly go with the amplifier from the ko-fi store, but as of writing this, I haven't fully understood it myself and are just in the first capture stage) </p> <p></p> </li> </ul> <p>To make it clear if you're a bit overwhelmed with all the connectors: These are really only for convenience. Theoretically, just a long enough bare coaxial cable would be enough, the connectors are just for convenience to allow you unplugging it and integrating the amplifier (you don't need to know about the amplifier yet).</p> <p>For all the cables you should get ones with 50 Ohm (usually specified in the product title or description).</p> <p>For the length, you should just measure how much you need and order ones as short as possible to avoid interference. But don't use too short ones to avoid wiring problems later on.</p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#start","title":"Start","text":"<p>Okay, so let's start. If you're reading this and haven't ordered your parts yet or you currently wait for them to arrive, keep on reading to get a better understanding of how it works. It'll help reading this (and the official vhs-decode wiki) multiple times, with some time between. You can also do some preparation already.</p> <p>First, find a place to put your VCR and (preferred dedicated) capture PC.</p> <p>Take a note of your VCR model name. Remove the cover from your VCR (most of the time the screws are on the sides and back).</p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#finding-the-test-point","title":"Finding the test point","text":"<p>For finding the test points, you should follow the official WIKI. As said, in the first step we're only going to capture video so we just need to find the video test point, although it won't hurt searching for the audio test point too. Note that if your VCR does not have Hi-Fi audio support (most of the time it's written on the tape cover on the front of your VCR), you won't find a audio test point because this test point is ONLY for capturing the Hi-Fi (better quality) audio. Not all VCRs support that and not all tapes have Hi-Fi audio in the first place. That means if your tape doesn't have Hi-Fi audio the Hi-Fi test point will be completely useless even if your VCR has one. In that case you'll need to capture the standard way with the standard audio output at the back of the VCR.</p> <p>VHS-Decode links for finding test points:</p> <ul> <li>General info: RF Tapping \u00b7 oyvindln/vhs-decode Wiki \u00b7 GitHub</li> <li>List of already found test points (check if your model is in there): 004 The Tap List \u00b7 oyvindln/vhs-decode Wiki \u00b7 GitHub</li> <li>Reports (check if your model (or manufacturer) is in there to get more info about your model): VCR reports \u00b7 oyvindln/vhs-decode Wiki \u00b7 GitHub</li> </ul> <p>If you can't find the test points by looking at the PCBs inside of the VCR, search the web for a service manual for your specific model. It's not that easy to read them if you haven't read service manuals before, but it can definitively help. For example in my case there was a white connector with 6 pins on the board, but only labelled with a cryptic name. I found it in the service manuals and there was also the description what each pin does, one of them was the test point that we need. If your service manual contains a troubleshooting section, that can be very helpful too.</p> <p>Sadly, it's not always easy to find the correct service manual. If you have luck, you directly find it when searching google for your model number and writing <code>service manual</code> behind it. You'll have issues finding it most of the time if you have a re-branded model (no main brand like JVC, Sony, ...). In my case I have an <code>AGFAPHOTO DV 18909R</code> and I couldn't find a service manual at all. After opening it up and removing the whole tape unit, I saw another model number printed on the mainboard. This revealed the actual manufacturer (which was Daewoo). That still wasn't enough because that model number from the mainboard didn't really exist, but luckily when typing it in google gave me a normal user manual with a VCR that looked identical to mine. And it contained the actual model number of the unit itself. All I had to do was type in this newly found model number and - I got my service manual! All I want to say with this is, it's very likely that your service manual is somewhere out there, you just need to hunt it down.</p> <p>If you still can't find the test point with the service manual, someone at the vhs-decode subreddit or on the Discord server may be able to help you. But if ask there, you should have your service manual ready to get the best help.</p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#wiring","title":"Wiring","text":"<p>You've found your test point. If you didn't find it yet, you can skip to CX Cards</p> <p>Get the SMA male cable with no connector on the other end. Solder that end to the capacitor. Use the official WIKI to find out how to connect the other end of the capacitor to your test point. Now you have a SMA male connector that goes to your test point. Then use the other cables to extend it and to get a final BNC male output. You can also prepare the other cable for Hi-Fi audio capture.</p> <p></p> <p></p> <p></p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#cx-cards","title":"CX Cards","text":"<p>First find out what model you've got and if it's good: https://github.com/happycube/cxadc-linux3/wiki/Types-Of-CX2388x-Cards They even ship different models if you order multiple at once. For me, one had the CX23883 and the other the CX25800 chip.</p> <p>Now we're going to do the following mods:</p> <ul> <li>RCA to BNC replacement / adding</li> <li>C31 Removal / moving</li> </ul> <p>In my case I'm using the 3rd connector (and not replacing the middle connector) because one of the cards already had the hole. For the other one, I'm going to drill the hole myself. After having the BNC connector installed, do the C31 removal (or move it to the other pad if you're using the 3rd connector like I do).</p> <p>Because I will do the clockgen mod later anyway (which I really recommend to avoid sync issues) and just want to see if it's working at all right now, I'm not going to do the crystal replacement mod.</p> <p>After your card is ready, install it to your capturing PC. I recommend not connecting the previously made BNC male output from the VCR yet before the driver is installed.</p> <p></p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#the-software-part","title":"The software part","text":""},{"location":"blog/2025/12/06/vhs-decode---part-1/#cx-card-driver","title":"CX card driver","text":""},{"location":"blog/2025/12/06/vhs-decode---part-1/#checking-if-the-card-is-recognized","title":"Checking if the card is recognized","text":"<p>After installing the driver, the card should be there as <code>/dev/cxadc0</code>. You can check this with this command: <code>ls /dev/cxadc0</code> If it returns the path, your card is properly recognized! If it says the path cannot be found, something went wrong.</p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#installing-the-driver","title":"Installing the driver","text":"<p>For installing the driver, follow the instructions of the driver's README: GitHub - happycube/cxadc-linux3</p> <p>First you must install the dependencies, download the repo to your local disk and then build it. After that, reboot and check if the card is recognized.</p> <p>For installing the dependencies, If you're using a different repo than what's listed there (currently only Ubuntu 22.04 or RPi OS),  AI can help relatively good with getting the dependencies that you need to install on your distro. In my case I've use openSUSE. Although it worked for me, I recommend just using a distro (currently Ubuntu) that's supported by the official WIKI if you use a dedicated PC.</p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#connecting-the-cables","title":"Connecting the cables","text":"<p>Now after the driver is working, it's a good time to connect the cable with the BNC plug from your VCR to the CX card.</p> <p></p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#find-the-correct-vmux-input","title":"Find the correct <code>vmux</code> input","text":"<p>The CX cards have 3 inputs, depending on your card and which of the two RCA inputs you've used, you need to find the correct output.</p> <p>For finding the correct <code>vmuc</code> input, check this wiki: Types Of CX2388x Cards \u00b7 happycube/cxadc-linux3 Wiki</p> <p>To configure the correct <code>vmux</code> input, you must execute this command: <code>echo 1 &gt;/sys/class/cxadc/cxadc0/device/parameters/vmux</code> Replace the number after <code>echo</code> with the input you want to use. This is explained here as an example: https://github.com/happycube/cxadc-linux3?tab=readme-ov-file#module-parameters</p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#driver-setup","title":"Driver setup","text":"<p>You should read trough the driver's README to get an overview of all the things you that you can adjust. I'm not fully sure (because I played around with it because I had no signal at all at first (but at the end the issue was something else, see troubleshooting below)), but I think it's not needed and is only fine adjusting.</p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#testing-the-signal","title":"Testing the signal","text":"<p>After successfully installing the driver, we can now finally test if we receive a signal from our VCR. For this, we use ffplay: https://github.com/happycube/cxadc-linux3?tab=readme-ov-file#commands-to-check-for-signal-burst</p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#making-the-first-capture","title":"Making the first capture","text":""},{"location":"blog/2025/12/06/vhs-decode---part-1/#folder-structure","title":"Folder structure","text":"<p>For initial testing, a relatively small disk is okay. But for doing longer captures, you'll need a lot of storage space. For testing, I just made a folder in my home directory. My folder structure as example:</p> <pre><code>workdir\n  captures\n    some-capture.u8\n  decoded\n    some-capture.tbc\n    some-capture_chroma.tbc\n    some-capture.json\n    some-capture.log\n  export\n    some-capture.mkv\n  tools\n</code></pre>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#getting-required-software","title":"Getting required software","text":"<p>Download the <code>tbc-tools</code> archive and the <code>vhs-decode</code> AppImage from: Releases \u00b7 oyvindln/vhs-decode \u00b7 GitHub. Extract the tbc-tools archive into your tools folder. Also place your AppImage there.</p> <p>Download the <code>tbc-video-export</code> AppImage from: Releases \u00b7 JuniorIsAJitterbug/tbc-video-export \u00b7 GitHub</p> <p>Example:</p> <pre><code>.\n\u2514\u2500\u2500 workdir/\n    \u2514\u2500\u2500 tools/\n        \u251c\u2500\u2500 tbc-tools/\n        \u2502   \u251c\u2500\u2500 40msps-to-10msps-8-bit-HiFi.sh\n        \u2502   \u251c\u2500\u2500 ld-compress\n        \u2502   \u251c\u2500\u2500 tbc-tools-x86_64.AppImage\n        \u2502   \u2514\u2500\u2500 ...\n        \u251c\u2500\u2500 vhs-decode-x86_64.AppImage\n        \u2514\u2500\u2500 tbc-video-export-v0.1.8-amd64.AppImage \n</code></pre>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#capturing","title":"Capturing","text":"<p>To capture a 10 seconds clip, execute this command (execute inside of your captures folder): <code>timeout 10s cat /dev/cxadc0 |pv &gt; captures/CX_Card_28msps_8-bit.u8</code></p> <p>With that, you receive your capture in this file: <code>CX_Card_28msps_8-bit.u8</code></p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#decoding","title":"Decoding","text":"<p>After getting the <code>.u8</code> file, we can now decode it. In my case the command is: <code>tools/vhs-decode-x86_64.AppImage vhs --debug --tape_format vhs --system pal --cxadc --threads 8 --recheck_phase captures/CX_Card_28msps_8-bit.u8 decoded/CX_Card_28msps_8-bit</code></p> <p>For more information, see here: RF Capture Decoding Guide \u00b7 oyvindln/vhs-decode Wiki \u00b7 GitHub</p> <p>Note that the output path does not have a file ending. That's because it will actually create multiple output files.</p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#analysing","title":"Analysing","text":"<p>Now that we have our <code>.tbc</code> files, we can analyse them by starting <code>ld-analyse</code> (this opens a GUI, it will throw an error if you're doing it over SSH): <code>tools/tbc-tools/tbc-tools-x86_64.AppImage decoded/CX_Card_28msps_8-bit.tbc</code></p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#exporting","title":"Exporting","text":"<p>Run the export command: <code>tools/tbc-video-export.AppImage --tbc-tools-appimage tools/tbc-tools/tbc-tools-x86_64.AppImage decoded/tape-2025-12-06.01.tbc</code></p> <p>Move the exported files to the export folder:<code>mv decoded/*.mkv export</code></p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#finished","title":"Finished!","text":"<p>You can now watch your <code>.mkv</code> file! But as explained at the beginning, we don't have any audio yet and the quality can probably be improved by tuning hardware &amp; software.</p> <p>Although it isn't needed yet in the testing stage, I still want to mention that you can use tools like <code>Handbrake</code> to encode your <code>.mkv</code> file to make it smaller (depending on the settings you'll lose quality the more you compress it at the reward of disk space).</p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#troubleshooting","title":"Troubleshooting","text":""},{"location":"blog/2025/12/06/vhs-decode---part-1/#very-bad-results","title":"Very bad results","text":"<p>When I tried to preview the signal with ffplay and did my first capture, the results were very bad (unusable). But I've just made the very dumb mistake that I did not ground it properly. I just soldered the cable to the video test point but did not solder to the shielding. I'm actually surprised that it worked at all and that it not went up in smokes. To ground it properly, just solder the cable's shielding to some metal inside the VCR. In my case I've used the metal box of the TV signal in/output, you can see the yellow cable in my wiring images above.</p>"},{"location":"blog/2025/12/06/vhs-decode---part-1/#no-signal-at-all-ffplay-shows-no-noise","title":"No signal at all / ffplay shows no noise","text":"<p>Note: If you've got a good connection and no tape is playing, it's normal that there is no noise. I've had a really weird issue that after powering on / rebooting the PC, there is just no signal at all. No noise. Nothing. Accidentally I found how to make it work: I need to put the PC to sleep (suspend) and then wake it up again. After that, the card works.</p>"},{"location":"docs/mkdocs-syntax-examples/","title":"MKDocs Syntax Examples","text":""},{"location":"docs/mkdocs-syntax-examples/#mkdocs-syntax-examples","title":"MKDocs Syntax Examples","text":""},{"location":"docs/mkdocs-syntax-examples/#syntax-testing","title":"Syntax testing","text":"test.yaml<pre><code>a:\n  aa: \"aa\"\n  ab: \"ab\"\nb:\n  ba: \"ba\"\n  bb: \"bb\"\n</code></pre> PythonJavaScript <pre><code>def main():\n    print(\"Hello world!\")\n</code></pre> <pre><code>console.log(\"Hello world\")\n</code></pre> <p>Note</p> <p>This is a simple note.</p> <p>Warning</p> <p>This is a warning!</p> <p>Danger!</p> <p>This is dangerous!</p> Collapsible <p>This is an important text!</p>"},{"location":"docs/Tools%20and%20scripts/Windows/extract-archives-withing-subfolders/","title":"Extract archives within subfolders (WinRAR)","text":""},{"location":"docs/Tools%20and%20scripts/Windows/extract-archives-withing-subfolders/#extract-archives-within-subfolders-winrar","title":"Extract archives within subfolders (WinRAR)","text":"<p>Having a lot of archived, all in their own sub-folder?</p> <pre><code>.\n\u2514\u2500\u2500 main-folder/\n    \u251c\u2500\u2500 sub-folder1/\n    \u2502   \u2514\u2500\u2500 archive.rar\n    \u251c\u2500\u2500 sub-folder2/\n    \u2502   \u2514\u2500\u2500 archive.rar\n    \u251c\u2500\u2500 sub-folder3/\n    \u2502   \u2514\u2500\u2500 archive.rar\n    \u2514\u2500\u2500 sub-folder4/\n        \u2514\u2500\u2500 archive.rar\n</code></pre> <p>You can extract all of them with this command from the <code>main-folder</code>: </p><pre><code>dir -Recurse | % {$_.FullName} | Split-Path | Get-Unique | % {cd $_ ; &amp; \"C:\\Program Files\\WinRAR\\Rar.exe\" x *.rar}\n</code></pre><p></p> <p>I sadly can't currently say if this also works with splitted archives because it's been a while since I used this command and I no longer have a Windows PC nor subfolders with archives in them. But as far as I remember I used it for splitted archives.</p>"},{"location":"docs/android/sideload-an-android-app-and-spoofing-the-installer/","title":"Sideload an Android App and spoofing the installer","text":""},{"location":"docs/android/sideload-an-android-app-and-spoofing-the-installer/#sideload-an-android-app-and-spoofing-the-installer","title":"Sideload an Android App and spoofing the installer","text":"<p>When installing an Android app, the system keeps track of where it came from. For example, if you install an app from the Google Play Store, the app info will show something like \"Installed from Google Play Store\". Normally, it doesn't matter where the app came from, but in some cases like Android Auto, it does.</p> <p>Android Auto does not show apps that were installed from sources other than Google Play. This prevents you from using modded apps in AA (e.g. Spotify,...).</p> <p>You can enable developer mode in AA, but in my case, the apps from different sources do not always show up and I have to reconnect AA in hopes it will be there on the next try. With spoofing the installed app, it is way more consistent (however it's still missing sometimes) and you don't need to enable the developer mode.</p> <p>To do this, you just need to use the <code>-i</code> argument and define the package name of the installer app: </p><pre><code>adb install -i \"com.android.vending\" -r .\\path\\to\\your.apk\n</code></pre><p></p>"},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/","title":"Set up Raspberry Pi as web kiosk","text":""},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/#set-up-raspberry-pi-as-web-kiosk","title":"Set up Raspberry Pi as web kiosk","text":""},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/#compatibility","title":"Compatibility","text":"<p>These instrutions haven't been fully tested from start to end because they were created after I set up the two kiosks I currently have. It should work with any recent Raspberry Pi OS (e.g. 12) though. Let me know if there's a issue somewhere in these instructions.</p>"},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/#preparations","title":"Preparations","text":"<ul> <li>Install the headless RPi OS (if you need to use the desktop variant for some reason, configure it to boot to console)</li> <li>Make sure auto-login is enabled:<ul> <li><code>sudo raspi-config</code> -&gt; 1 System Options -&gt; S6 Auto Login -&gt; Yes</li> </ul> </li> <li>Make sure <code>openbox</code> is installed</li> <li>Make sure <code>unclutter</code> is installed (optional, can be commented out in the script below)</li> </ul>"},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/#display-browser-setup","title":"Display &amp; Browser setup","text":"<ol> <li> <p>Create/modify the file <code>/home/pi/.xinitrc</code>and add: </p>/home/pi/.xinitrc<pre><code>#!/bin/bash\nopenbox-session &amp;\nexec /home/pi/kiosk.sh\n</code></pre><p></p> </li> <li> <p>Set the correct permissions: <code>chmod +x /home/pi/.xinitrc</code></p> </li> <li> <p>Create/modify the file <code>/home/pi/.bash_profile</code> and add: </p>/home/pi/.bash_profile<pre><code>[[ -z $DISPLAY &amp;&amp; $XDG_VTNR -eq 1 ]] &amp;&amp; startx -- -nocursor\n</code></pre><p></p> </li> <li> <p>Set the correct permissions: <code>chmod +x /home/pi/.bash_profile</code></p> </li> <li> <p>Create the file <code>/home/pi/kiosk.sh</code> and add: </p>/home/pi/kiosk.sh<pre><code>#!/bin/bash\n\nURL=\"http://homeassistant.local\"\nCHROMIUM_PREFERENCES_FILE=\"/home/$USER/.config/chromium/Default/Preferences\"\n\n# Remove mouse cursor (optional)\nunclutter -idle 5 -root &amp;\n\n# Disable screensavers (if they are enabled by default)\nxset -dpms\nxset s off\nxset s noblank\n\n# Prevent Chromium addons from automatically updating (which may open a new tab which is then displayed instead of our kiosk page)\nsed -i 's|\"update_url\":\"https://clients2.google.com/service/update2/crx\"|\"update_url\":\"https://localhost\"|' \"$CHROMIUM_PREFERENCES_FILE\"\n\n# Remove warning popups in Chrome\nsed -i 's/\"exited_cleanly\":false/\"exited_cleanly\":true/' /home/$USER/.config/chromium/Default/Preferences\nsed -i 's/\"exit_type\":\"Crashed\"/\"exit_type\":\"Normal\"/' /home/$USER/.config/chromium/Default/Preferences\n\n####################################################################################\n## Choose your browser by uncommenting either \"chromium-browser\" or \"firefox-esr\" ##\n####################################################################################\n\n# Launch chromium browser\n#chromium-browser --noerrdialogs --disable-infobars --kiosk \"$URL\"\n\n# Some more chrome flags that can be used:\n# --hide-scrollbars\n\n# Launch Firefox\n#firefox-esr --kiosk \"$URL\"\n</code></pre><p></p> </li> <li> <p>Set the correct permissions: <code>chmod +x /home/pi/kiosk.sh</code></p> </li> <li>Reboot. The kiosk should automatically start on the next boot.</li> </ol>"},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/#custom-browser-scripts","title":"Custom browser scripts","text":"<p>You can use the browser extension Tampermonkey for writing custom browser scripts. With such a script, you can e.g. automatically fill in form fields and click buttons, very useful if you need to log in somewhere.</p> <p>In some cases, such a script will not work after rebooting because the browser window may not be focused properly. In that case it can help to (virtually) press a key.</p> <ol> <li> <p>Create a new script, e.g. <code>/home/pi/press-key.sh</code> </p><pre><code>#!/bin/bash\nxdotool key F2\n</code></pre><p></p> </li> <li> <p>Set the correct permissions: <code>chmod +x /home/pi/press-key.sh</code></p> </li> <li> <p>Install a cronjob (<code>crontab -e</code>) </p><pre><code># Execute key-press script to focus browser to allow custom scripts\n* * * * * DISPLAY=:0 /home/pi/press-key.sh\n</code></pre><p></p> </li> </ol>"},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/#setup-daily-reboots","title":"Setup daily reboots","text":"<p>To make sure there are no permanent hangs (e.g. a website that no longer refreshes on its own) and to keep the system more reliable, you should set up daily rebooting. You can do this by setting up a cronjob (<code>crontab -e</code>) with: <code>0 3 * * * sudo reboot</code></p>"},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/#finalize-setup","title":"Finalize setup","text":"<p>If everything is set up and works correctly, you can enable the overlay file system on the raspberry pi.</p> <ul> <li><code>sudo raspi-config</code> -&gt; 4 Performance Options -&gt; P2 Overlay File System -&gt; Yes -&gt; Ok -&gt; No -&gt; Ok -&gt; Reboot</li> </ul> <p>You can keep the boot partition writeable as normally there isn't written much anyway.</p> <p>The overlay file system will not only greatly reduce SD card wear but also prevents corruption, full storage issues or similar. This will give you a setup that should require little to no maintenance. For making updates or other changes, don't forget to disable the overlay file system before doing them, otherwise everything will be reverted on the next reboot.</p>"},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/#what-the-overlay-file-system-actually-does","title":"What the overlay file system actually does","text":"<p>If the overlay file system is enabled, your Raspberry Pi\u2019s root filesystem is mounted as read-only, and a temporary writable layer (in RAM) is placed on top. You can still \"write\" files (create, edit, or delete them) just like normal, but all changes are stored in the temporary layer. After a reboot, everything is reset to the previous state because the modifications in the temporary layer are discarded and the underlying system remains unchanged. With a standard read-only filesystem, modifying files would not be possible at all.</p>"},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/#wifi-troubleshooting","title":"WiFi troubleshooting","text":"<p>If you experience conenctivity issues, here are some troubleshooting steps you can try.</p>"},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/#find-out-whats-causing-issues","title":"Find out what's causing issues","text":"<p>Example commands that can help you identify the problem:</p> <ul> <li><code>iw wlan1 link</code> - Check the signal strength (60-70 should be okay, -80 dBm or lower is really bad)</li> <li><code>sudo journalctl -u wpa_supplicant --since \"8 hours ago\"</code></li> <li><code>sudo journalctl -u NetworkManager --since \"8 hours ago\"</code></li> <li><code>sudo journalctl -b --since \"8 hours ago\" | grep wlan</code></li> </ul>"},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/#set-infinity-reconnect-attempts-untested-if-that-really-works","title":"Set infinity reconnect attempts (untested if that really works)","text":"<p>Create and edit the file <code>/etc/NetworkManager/conf.d/99-retry.conf</code>: </p><pre><code>[connection]\nautoconnect-retries=0  # 0 means infinite\n</code></pre><p></p>"},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/#for-hidden-networks-currently-not-sure-if-it-really-improves-anything-well-see","title":"For hidden networks (currently not sure if it really improves anything, we'll see)","text":"<p>Make sure that your network service knows that it's hidden.</p>"},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/#if-using-nmcli","title":"If using nmcli","text":"<p>Type <code>nmcli connection show &lt;network-name&gt;</code> and look for the line <code>802-11-wireless.hidden</code>. If it's set to <code>yes</code> and your network is hidden, it's already set up correctly. If it's set to <code>no</code>, you should set it to <code>yes</code> with <code>sudo nmcli connection modify &lt;network-name&gt; 802-11-wireless.hidden yes</code></p>"},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/#if-using-wpa_supplicant-directly","title":"If using wpa_supplicant directly","text":"<p>Add this line in your network config, e.g. add it below <code>psk=xxx</code>: <code>scan_ssid=1</code></p>"},{"location":"docs/hardware/kiosk/raspberry-pi-kiosk-webpage/#how-to-find-out-what-youre-using","title":"How to find out what you're using","text":"<p>If <code>/etc/wpa_supplicant/wpa_supplicant.conf</code> contains your network config, you're using <code>wpa_supplicant</code> directly. If <code>/etc/wpa_supplicant/wpa_supplicant.conf</code> does not contain your network config or does not exist at all, you're likely not using <code>wpa_supplicant</code>. Check if the command <code>nmcli connection show</code> shows your connected wifi network. If it shows it, you're using <code>nmcli</code>.</p>"},{"location":"docs/hardware/storage/filesystems/encryption-with-luks-usb/","title":"Disk encryption with LUKS and using USB stick to unlock","text":""},{"location":"docs/hardware/storage/filesystems/encryption-with-luks-usb/#disk-encryption-with-luks-and-using-usb-stick-to-unlock","title":"Disk encryption with LUKS and using USB stick to unlock","text":"<p>Danger!</p> <p>Make sure to always replace <code>/dev/sdX</code> with the correct disk. Using the wrong path can and likely will cause data loss!</p>"},{"location":"docs/hardware/storage/filesystems/encryption-with-luks-usb/#creating-a-new-usb-key","title":"Creating a new USB key","text":"<ol> <li>Execute <code>lsblk</code> and find the path of your usb drive (e.g. <code>/dev/sdb</code>)</li> <li>Make new label: <pre><code>sudo parted /dev/sdX \"mklabel gpt\"\n</code></pre> <pre><code>yes\n</code></pre></li> <li>Make partitions: <pre><code>sudo cfdisk /dev/sdX\n</code></pre> <pre><code>new - enter\nenter\ntype - enter\n    Linux Filesystem - enter\nwrite - enter\nyes - enter\nquit - enter\n</code></pre></li> <li>Formatting: <pre><code>sudo mkfs.ext4 /dev/sdX\n</code></pre> <pre><code>y\n</code></pre></li> <li>Generate key and write it to usb stick: <pre><code>sudo dd if=/dev/urandom of=/dev/sdX bs=512 seek=1 count=2046 \n</code></pre></li> <li>Proceed with Extracting a bin key file from USB key and then Adding a bin key file to a disk</li> </ol>"},{"location":"docs/hardware/storage/filesystems/encryption-with-luks-usb/#extracting-a-bin-key-file-from-usb-key","title":"Extracting a bin key file from USB key","text":"<p><code>dd if=/dev/sdX bs=512 skip=1 count=16 of=recoveredKeyFile.bin</code></p>"},{"location":"docs/hardware/storage/filesystems/encryption-with-luks-usb/#adding-a-bin-key-file-to-a-disk","title":"Adding a bin key file to a disk","text":"<p><code>cryptsetup luksAddKey /dev/sdX keyFile.bin</code></p>"},{"location":"docs/hardware/storage/filesystems/encryption-with-luks-usb/#automatic-unlocking-on-boot-by-plugging-in-usb-key-on-boot","title":"Automatic unlocking on boot (by plugging in USB key on boot)","text":"<p>Configure crypttab (example, replace with your values, see table below):</p> <p>Note</p> <p>When having multiple disks, you must increment the <code>sda-crypt</code> alphabetically.</p> /etc/crypttab<pre><code>sda-crypt UUID=65fc9547-361c-40dd-bf45-d26828c5ae0d /dev/disk/by-id/usb-Verbatim_STORE_N_GO_12073991000507-0:0 luks,tries=3,keyfile-size=8192,keyfile-offset=512\n</code></pre> Option Description UUID UUID of encrypted disk, find out using <code>blkid \\| grep crypto_LUKS</code> /dev/disk/by-id/xxx Name / ID of USB stick used for unlocking, find out using <code>ls -l /dev/disk/by-id</code>"},{"location":"docs/hardware/storage/filesystems/encryption-with-luks-usb/#backup-luks-header","title":"Backup LUKS header","text":"<p><code>cryptsetup luksHeaderBackup /dev/sdX --header-backup-file DATA_HDD_2.luks.bin</code></p>"},{"location":"docs/hardware/storage/filesystems/encryption-with-luks-usb/#sources","title":"Sources","text":"<ul> <li>https://knilix.home.blog/luks-encryption/ (german)</li> </ul>"},{"location":"docs/media/video-encoding/benchmark-with-ffmpeg/","title":"Benchmark with ffmpeg","text":""},{"location":"docs/media/video-encoding/benchmark-with-ffmpeg/#benchmark-with-ffmpeg","title":"Benchmark with ffmpeg","text":"<p>This simple test lets you compare how fast your machine is at encoding videos.</p> <p>Just use a sample video like this one: <code>wget https://filesamples.com/samples/video/mkv/sample_1280x720_surfing_with_audio.mkv</code></p> <p>And start ffmpeg: <code>ffmpeg -i sample_1280x720_surfing_with_audio.mkv -c:v libx265 -preset medium -crf 20 -an -f null -</code></p> <p>Sample output: <code>encoded 4389 frames in 163.39s (26.86 fps), 3440.14 kb/s, Avg QP:23.81</code></p>"},{"location":"docs/networking/problems/issues-with-specific-wifi-network-only-working-few-seconds/","title":"Specific (Wi-Fi) Network works for few seconds, breaks, then works again for few seconds","text":""},{"location":"docs/networking/problems/issues-with-specific-wifi-network-only-working-few-seconds/#specific-wi-fi-network-works-for-few-seconds-breaks-then-works-again-for-few-seconds","title":"Specific (Wi-Fi) Network works for few seconds, breaks, then works again for few seconds","text":""},{"location":"docs/networking/problems/issues-with-specific-wifi-network-only-working-few-seconds/#story","title":"Story","text":"<p>So I had really weird network problems on one specific Wi-Fi network on my laptop running Kubuntu.</p> <p>The problem was that the network worked a few seconds after connecting, then stopped working for a few seconds and then come back for a few seconds, over and over again. Sometimes it would not recover though. Even using ping, the responses were interrupted, so a DNS or firewall problems seemed unlikely. The connection status was still connected. Because the network requires PEAP authentication, I thought that this would be the problem (especially because it worked on all other devices I had).</p> <p>But after trying all kinds of things, thinking it the network would block something or an authentication issue, the problem was rather simple.</p> <p>Turns out, Docker, which was running on my laptop, was the problem because it was using the same network range (127.x.x.x).</p>"},{"location":"docs/networking/problems/issues-with-specific-wifi-network-only-working-few-seconds/#solution","title":"Solution","text":"<p>To verify that Docker was actually causing this issue, I have stopped it and deleted the network (will be recreated automatically when starting Docker again): </p><pre><code>sudo systemctl stop docker\nsudo ip link delete docker0\n</code></pre><p></p> <p>Directly after executing these commands, the network instantly worked flawlessly. To keep using Docker while on this network, we need to change the Docker subnet.</p> <p>Create/Modify this file and add this option: </p>/etc/docker/daemon.json<pre><code>{\n  \"bip\": \"192.168.100.1/24\"\n}\n</code></pre><p></p> <p>Then restart Docker: </p><pre><code>sudo systemctl restart docker\n</code></pre><p></p>"},{"location":"docs/networking/tools/iperf3-network-speed-tests/","title":"iperf3: Network speed tests","text":""},{"location":"docs/networking/tools/iperf3-network-speed-tests/#iperf3-network-speed-tests","title":"iperf3: Network speed tests","text":"<p>iperf 3 is a useful tool that allows you to easily do (local) network speed tests between two computers.</p>"},{"location":"docs/networking/tools/iperf3-network-speed-tests/#usage","title":"Usage","text":""},{"location":"docs/networking/tools/iperf3-network-speed-tests/#server","title":"Server","text":"<pre><code>iperf3 -s\n</code></pre> After executing this command, the server is started and no longer needs to be touched. All the test related options are used from the client side."},{"location":"docs/networking/tools/iperf3-network-speed-tests/#client","title":"Client","text":"<p>To start a basic upload (client -&gt; server) speed test, type this command:  </p><pre><code>iperf3 -c x.x.x.x\n</code></pre> Replace <code>x.x.x.x</code> with the IP address of the server.<p></p>"},{"location":"docs/networking/tools/iperf3-network-speed-tests/#options","title":"Options","text":"<p>You can add options to the client command to e.g. reverse the speed test (upload/download) or do a bidirectional speed test (upload and download at the same time).</p> <p>Here is a short list of the probably most used options:</p> Option Description <code>-R</code> Run in reverse mode (server sends, client receives) <code>--bidir</code> Run in bidirectional mode <code>-t 30</code> Time in seconds (e.g. 30s) to transmit for (default 10 secs) <p>To get the full list of options + descriptions, type: </p><pre><code>iperf3 --help\n</code></pre><p></p>"},{"location":"docs/networking/tools/iperf3-network-speed-tests/#installation","title":"Installation","text":""},{"location":"docs/networking/tools/iperf3-network-speed-tests/#debianubuntu","title":"Debian/Ubuntu","text":"<pre><code>sudo apt install iperf3\n</code></pre>"},{"location":"docs/networking/tools/iperf3-network-speed-tests/#fedora-red-hat-centos-rocky","title":"Fedora / Red Hat / CentOS / Rocky","text":"<pre><code>yum install iperf3\n</code></pre>"},{"location":"docs/networking/tools/iperf3-network-speed-tests/#alpine-linux-often-used-for-docker-containers","title":"Alpine Linux (often used for docker containers)","text":"<pre><code>apk add iperf3\n</code></pre>"},{"location":"docs/networking/tools/iperf3-network-speed-tests/#freebsd","title":"FreeBSD","text":"<pre><code>sudo pkg install benchmarks/iperf3\n</code></pre>"},{"location":"docs/networking/tools/iperf3-network-speed-tests/#macos","title":"macOS","text":"<pre><code>brew install iperf3\n</code></pre>"},{"location":"docs/networking/tools/iperf3-network-speed-tests/#windows","title":"Windows","text":"<p>Download the latest version of iPerf3 from the official website: iPerf3 Download</p>"},{"location":"docs/networking/tools/iperf3-network-speed-tests/#android","title":"Android","text":"<p>Useful networking app that also integrates iPerf 3: PingTools Network Utilities</p>"},{"location":"docs/networking/tools/iperf3-network-speed-tests/#run-as-service","title":"Run as service","text":"<p>To always let the server run without opening a terminal, you can create an iperf3 service that automatically gets started on boot.</p> <p>Create this file: </p>/etc/systemd/system/iperf3.service<pre><code>[Unit]\nDescription=iperf3 server\nAfter=syslog.target network.target auditd.service\n\n[Service]\nExecStart=/usr/bin/iperf3 -s\n\n[Install]\nWantedBy=multi-user.target\n</code></pre><p></p> <p>Reload systemctl (this is needed after creating/modifying systemd service files): </p><pre><code>systemctl daemon-reload\n</code></pre><p></p> <p>Start the iperf3 server: </p><pre><code>systemctl start iperf3\n</code></pre><p></p> <p>Enable it so that it automatically start back up on reboot: </p><pre><code>systemctl enable iperf3\n</code></pre><p></p> <p>Inspired by: https://askubuntu.com/questions/1251443/start-iperf3-deamon-at-startup</p>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2025/#2025","title":"2025","text":""}]}